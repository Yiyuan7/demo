"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tick_manager_1 = require("tick-manager");
var viewport_details_1 = require("viewport-details");
var prevent_scrolling_1 = require("prevent-scrolling");
var Easings = require("js-easing-functions");
var models_1 = require("./models");
var user_scroll_events_1 = require("./user-scroll-events");
var win = window;
var body = document.body;
var defaultOptions = {
    offset: [0, 0],
    duration: [200, 5000],
    easing: models_1.Easing.easeInOutQuart,
    cancelOnUserScroll: true,
    animate: true,
    autoDurationMultiplier: 2,
};
var ScrollableArea = /** @class */ (function () {
    function ScrollableArea(scrollContainer) {
        this.scrollContainer = scrollContainer;
        this.ticking = false;
        this._scrolling = false;
        this.userScrollingPrevented = false;
        // Hack to ensure event listeners are removed correctly and their functions retain context of this. See:
        // https://stackoverflow.com/questions/11565471/removing-event-listener-which-was-added-with-bind#answer-33386309
        this.cancelScroll = this.cancelScroll.bind(this);
    }
    ScrollableArea.prototype.ScrollToTarget = function (target, options) {
        var _this = this;
        if (!Array.isArray(target)) {
            target = [target.offsetLeft, target.offsetTop];
        }
        var _a = __assign({}, defaultOptions, options), offset = _a.offset, easing = _a.easing, animate = _a.animate, duration = _a.duration, cancelOnUserScroll = _a.cancelOnUserScroll, autoDurationMultiplier = _a.autoDurationMultiplier;
        this.setScrollPosition();
        this.easing = Easings[easing];
        this.scrollFrom = [this.scrollX, this.scrollY];
        this.scrollTo = [target[0] + offset[0], target[1] + offset[1]];
        return new Promise(function (resolve) {
            if (_this.scrollFrom === _this.scrollTo) {
                resolve();
            }
            else {
                _this.scrolling = true;
                _this.resolve = resolve;
                if (animate) {
                    var scrollHeight = void 0;
                    var scrollWidth = void 0;
                    if (_this.scrollContainer instanceof Window) {
                        var viewport = viewport_details_1.GetViewportDetails();
                        scrollWidth = body.offsetWidth - viewport.width;
                        scrollHeight = body.offsetHeight - viewport.heightCollapsedControls;
                    }
                    else {
                        scrollWidth = _this.scrollContainer.scrollWidth;
                        scrollHeight = _this.scrollContainer.scrollHeight;
                    }
                    _this.scrollTo[0] = Math.max(Math.min(_this.scrollTo[0], scrollWidth), 0);
                    _this.scrollTo[1] = Math.max(Math.min(_this.scrollTo[1], scrollHeight), 0);
                    var distanceX = Math.abs(_this.scrollFrom[0] - _this.scrollTo[0]);
                    var distanceY = Math.abs(_this.scrollFrom[1] - _this.scrollTo[1]);
                    var autoDuration = Math.max(distanceX, distanceY) * autoDurationMultiplier;
                    if (Array.isArray(duration)) {
                        _this.duration = Math.round(Math.min(Math.max(Math.round(autoDuration), duration[0]), duration[1]));
                    }
                    else {
                        _this.duration = duration;
                    }
                    _this.timestamp = Date.now();
                    if (cancelOnUserScroll) {
                        _this.addEventListeners();
                    }
                    else {
                        _this.userScrollingPrevented = true;
                        prevent_scrolling_1.PreventScrolling();
                    }
                    if (!_this.ticking) {
                        _this.ticking = true;
                        tick_manager_1.AddTick(_this.tick.bind(_this));
                    }
                }
                else {
                    (_a = _this.scrollContainer).scrollTo.apply(_a, _this.scrollTo);
                    _this.onScrollEnd();
                }
            }
            var _a;
        });
    };
    Object.defineProperty(ScrollableArea.prototype, "scrolling", {
        get: function () {
            return this._scrolling;
        },
        set: function (scrolling) {
            this._scrolling = scrolling;
            win.autoScrolling = scrolling;
        },
        enumerable: true,
        configurable: true
    });
    ScrollableArea.prototype.setScrollPosition = function () {
        if (this.scrollContainer instanceof Window) {
            this.scrollX = win.pageXOffset;
            this.scrollY = win.pageYOffset;
        }
        else {
            this.scrollX = this.scrollContainer.scrollLeft;
            this.scrollY = this.scrollContainer.scrollTop;
        }
    };
    ScrollableArea.prototype.addEventListeners = function () {
        var _this = this;
        user_scroll_events_1.USER_SCROLL_EVENTS.forEach(function (event) {
            _this.scrollContainer.addEventListener(event, _this.cancelScroll);
        });
    };
    ScrollableArea.prototype.removeEventListeners = function () {
        var _this = this;
        user_scroll_events_1.USER_SCROLL_EVENTS.forEach(function (event) {
            _this.scrollContainer.removeEventListener(event, _this.cancelScroll);
        });
    };
    ScrollableArea.prototype.cancelScroll = function () {
        this.scrolling = false;
        this.removeEventListeners();
    };
    ScrollableArea.prototype.tick = function () {
        this.setScrollPosition();
        if (this.scrolling) {
            this.scroll();
        }
    };
    ScrollableArea.prototype.onScrollEnd = function () {
        if (this.userScrollingPrevented) {
            prevent_scrolling_1.ReEnableScrolling();
        }
        this.removeEventListeners();
        this.scrolling = false;
        this.resolve();
    };
    ScrollableArea.prototype.scroll = function () {
        var elapsed = Date.now() - this.timestamp;
        var x;
        var y;
        if (elapsed < this.duration) {
            x = this.calculateNextPosition(0, elapsed);
            y = this.calculateNextPosition(1, elapsed);
        }
        else {
            x = this.scrollTo[0];
            y = this.scrollTo[1];
            this.onScrollEnd();
        }
        if (this.scrollContainer instanceof Window) {
            this.scrollContainer.scrollTo(x, y);
        }
        else {
            this.scrollContainer.scrollLeft = x;
            this.scrollContainer.scrollTop = y;
        }
    };
    ScrollableArea.prototype.calculateNextPosition = function (index, elapsed) {
        var from = this.scrollFrom[index];
        var to = this.scrollTo[index];
        if (from > to) {
            return from - this.easing(elapsed, 0, from - to, this.duration);
        }
        else {
            return from + this.easing(elapsed, 0, to - from, this.duration);
        }
    };
    return ScrollableArea;
}());
exports.ScrollableArea = ScrollableArea;
